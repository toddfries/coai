#!/usr/bin/perl

# Copyright (c) 2022 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use Config::Tiny;
use Data::Dumper;
use Getopt::Std;
use OpenAI::API;

our $opt_c; # config
our $opt_m; # model
our $opt_p; # prolog i.e. file to read in and send at the top of each query

# defaults
$opt_c = $ENV{'HOME'}."/.config/coai/key.conf";
$opt_m = 'text-davinci-003',

getopts('c:m:p:');

if (! -f $opt_c) {
	die "Can't open ${opt_c} to read in the key";
}

my $cobj = Config::Tiny->new();

my $config = $cobj->read($opt_c);
my $key = $config->{_}->{key};

my $openai = OpenAI::API->new( api_key => $key );

my $prolog;
if (defined($opt_p)) {
	open(P,$opt_p);
	my $line;
	while(<P>) {
		chomp($line = $_);
		$prolog .= $line."\n";
	}
	close(P);
}

my $prompt = "Query? (type 'done.' to end)\n";

my $l;
my $query = "";
print $prompt;
while(<STDIN>) {
	chomp($l = $_);
	if (! ($l =~ /^done.$/)) {
		$query .= $l."\n";
		next;
	}

	#print "Query: ".$query;
	if (defined($prolog)) {
		$query = "\n".$prolog."\n".$query;;
	}
	
	print "Sending...\n";

	my $response = $openai->completions(
		model => $opt_m,
		prompt => $query,
		max_tokens => 2048,
		temperature => 0.5,
		top_p => 1,
		frequency_penalty => 0,
		presence_penalty => 0
		# user => "uid"
	);
	# reset
	$query = "";


	print "Response(s):\n";
	if (defined(@{$response->{'choices'}}[0])) {
		foreach my $choice (@{$response->{'choices'}}) {
			printf "%2d. %s\n\n", $choice->{index}, $choice->{text};
			printf "     finish = %s\n", $choice->{'finish_reason'};
		}
		print "Stats: ";
		print $response->{'created'};
		printf " tot/prompt/compl tokens = %d/%d/%d\n",
			$response->{'usage'}->{'total_tokens'},
			$response->{'usage'}->{'prompt_tokens'},
			$response->{'usage'}->{'completion_tokens'},
		#print Dumper($response);
	} else {
		print Dumper($response);
	}
	print "\n";

	print $prompt;
}
